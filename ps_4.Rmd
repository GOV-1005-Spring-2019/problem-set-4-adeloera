---
title: "ps_4"
author: "Andres de Loera-Brust"
date: "February 25, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#I begin as always with loading the packages I will use.
library(gt)
library(tidyverse)
library(broom)

#Next I load in the poll data I will be using to answer the questions, adding the column types arguments to my code.
poll <- read_csv(
  file = "ps_4_elections-poll-nc09-3.csv",
  col_types = cols(
    .default = col_character(),
    turnout_scale = col_double(),
    turnout_score = col_double(),
    w_LV = col_double(),
    w_RV = col_double(),
    final_weight = col_double(),
    timestamp = col_datetime(format = "")))

```

## Question 1

There were `r poll %>% filter(response == "Dem") %>% nrow()` respondents who supported the Democratic candidate.

There were `r (filter(poll, response == "Rep") %>% nrow())-(filter(poll, response == "Und") %>% nrow())` more respondents who favored the Republican candidate than who were Undecided.

There are two gender variables (gender and gender_combined). There are `r filter(poll, gender != gender_combined) %>% nrow()` individuals for whom these variables have different values.

There are `r poll %>% filter(race_eth == "White", file_race_black != "White") %>% nrow()` respondents listed as “White” under race_eth who are not listed as “White” under file_race_black.

The first response of Rep came `r as.integer((poll %>% filter(response == "Dem") %>% arrange(timestamp) %>% select(timestamp) %>% slice(1))- (poll %>% filter(response == "Rep") %>% arrange(timestamp) %>% select(timestamp) %>% slice(1)))` minutes (rounded to the nearest minute) before the first response of Dem. In clearer language, the first response of Rep came (roughly) `r as.integer((poll %>% filter(response == "Rep") %>% arrange(timestamp) %>% select(timestamp) %>% slice(1))- (poll %>% filter(response == "Dem") %>% arrange(timestamp) %>% select(timestamp) %>% slice(1)))` minutes after the first response of Dem. 


## Question 2

```{r table, echo = FALSE} 
#To begin I create a dataset with the information and shape that we want: 
#A five by three table where each row represents an ethnicity 
#and the columns are the percentage of the vote for each party 

table <- poll %>% 
  #I begin by selecting only the variables I'll use: response, race/ethnicity, and the survey weights.
  select(response, race_eth, final_weight) %>% 
  #I then group by race/ethnicity and response to get total counts for each cell.
  group_by(race_eth, response) %>% 
  #When I sum to get total counts for each cell I need to use to survey weights to make sure my results are representative.
  summarize(total = sum(final_weight)) %>%   
  #Next I drop the observations I cant work with because they dont have one of the key variables.
  filter(race_eth != "[DO NOT READ] Don't know/Refused" ,response != "3") %>% 
  #Now I tidy the data to get the format we want
  spread(key =  response, value = total) %>%
  #Since there is an NA in the resulting table which will cause problems later I replace NA's with zeros.
  replace(is.na(.), 0) %>%
  #Now I turn the counts I have in each cell into proportions
  mutate(all = Dem + Rep + Und,
         Dem = Dem / all,
         Rep = Rep / all,
         Und = Und / all) %>% 
  select(-all) %>%
  #Finally I ungroup to make the gt commands below work. 
  ungroup()

#Now I use the gt package to turn the tibble I have into a chart like the one in the PSet description
#when I pipe the table into the gt command I first specify the order of the rows to match the ones in the sample chart.
table[c(5, 2, 3, 1, 4),] %>%
gt() %>% 
  #I add a title and subtitle to describe what the chart is showing.
  tab_header(
    title = "Polling Results in the North Carolina 9th Congressional District",
    subtitle = "Based on 3rd wave of polling, 10/26/18-10/31/18"
    ) %>% 
  #I also add a note about the source of our data, which appears to be The Upshot.
  tab_source_note(
    source_note = "Source: The UpShot"
    ) %>%
  #I use unabreviated column labels because I believe it is marginally clearer. 
  cols_label(
    race_eth = "Race/Ethnicity",
    Dem = "Democrat",
    Rep = "Republican",
    Und = "Undecided"
  ) %>%
  #I format the numbers, previously proportions, into percentages. 
  #I prefer not to round to the nearest integer because it creates the impression that the bottom row sums to 101%. 
  fmt_percent(columns = vars(Dem, Rep, Und),
              decimals = 2) 
  
```


## Question 3



## Question 4

